// clang-format off
#include "pch.h"
#ifdef __APPLE__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#endif  // __APPLE__
#include <aws/core/Aws.h>
#include <aws/core/http/HttpClient.h>
#include <gtest/gtest.h>
#include <gmock/gmock.h>
#ifdef __APPLE__
#pragma clang diagnostic pop
#endif  // __APPLE__
#include "unit_test_helper.h"
#include "opensearch_communication.h"

using namespace Aws::Client;
using namespace Aws::Http;
using namespace testing;

static const char host[] = "http://localhost:9200";

// Mock runtime options for testing
struct RuntimeOptions {
    struct Conn {
        std::string server = "http://localhost";
        std::string port = "9200";
        std::string timeout = "30";  // seconds
    } conn;

    struct Crypt {
        bool use_ssl = true;
        bool verify_server = true;
    } crypt;

    struct Auth {
        std::string auth_type = "OAUTH2";
        std::string access_token = "";
    } auth;
};

class MockOAuth2TokenProvider {
public:
    MOCK_METHOD(std::string, GetToken, (), (const));
};

class OpenSearchCommunicationTest : public ::testing::Test {
protected:
    OpenSearchCommunication* openSearchComm;
    RuntimeOptions rt_opts;
    std::shared_ptr<MockOAuth2TokenProvider> mockTokenProvider;

    void SetUp() override {
        mockTokenProvider = std::make_shared<NiceMock<MockOAuth2TokenProvider>>();
        openSearchComm = new OpenSearchCommunication();
        rt_opts.auth.auth_type = "OAUTH2";
        rt_opts.auth.access_token = mockTokenProvider->GetToken();
        openSearchComm->SetRuntimeOptions(rt_opts);
        openSearchComm->InitializeConnection();
    }

    void TearDown() override {
        delete openSearchComm;
    }
};

TEST_F(OpenSearchCommunicationTest, TokenAuthentication) {
    EXPECT_CALL(*mockTokenProvider, GetToken())
        .WillOnce(Return("eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICIxSkRWMEswT1ctN3FZc1ROUmNBVm5XZkgyT2NLZ0N1Z0Q0OGs1SHdQZ2tBIn0.eyJleHAiOjE3MTY0NTQyNTEsImlhdCI6MTcxNjQ1MjQ1MSwianRpIjoiYzEzODA3NzYtMDVjNy00MjQ2LWJhYzQtOWRmMTg3MmEzYTU2IiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDoxODUyL3JlYWxtcy9sb2NhbC1kZXZlbG9wbWVudCIsInN1YiI6IjAwNTQ1YTc2LTBlYjMtNDdlNy05OGVhLTE1Y2FkNDkzMTEyNSIsInR5cCI6IkJlYXJlciIsImF6cCI6Im9wZW5zZWFyY2gtYWRtaW4iLCJzY29wZSI6Im9wZW5zZWFyY2giLCJjbGllbnRIb3N0IjoiMTcyLjE4LjAuMSIsInJvbGVzIjpbIm9wZW5zZWFyY2hfYWxsX2FjY2VzcyJdLCJjbGllbnRBZGRyZXNzIjoiMTcyLjE4LjAuMSIsImNsaWVudF9pZCI6Im9wZW5zZWFyY2gtYWRtaW4ifQ.1-nNgT4Z94EKufPim7x8Hxk7jhc1DIvMXbWZKPDNwoi7WJrTPiZu_NMRKBN6Ee448122F2XGI0vUWQgV6QitYD0U3d65h8x61LepBzBQr8G5Q_Yc74AAw1azeCvrKvjDxK_AyLx3tcvqwHk_AsYqmQWxvO36ULEBKj5TZn5BAsmRiBLaEuHf045hvx1l-CacBlq32H99u62PD1kCdHJG0_o7Xwbrbl_IT-CyoOmQBq5zvtiEqe5P4tOFupJ9kEHhTIj3JdTi_zj0M_JRv-Y_mLgef8RyShCY4DyTup_N6pDfb4e6NZ5FLEn8gmXWTnlmykC8fm7NELCJb9DU1LJupw"));

    // Update the runtime options with the mocked token
    rt_opts.auth.access_token = mockTokenProvider->GetToken();
    openSearchComm->SetRuntimeOptions(rt_opts);

    std::string endpoint = "/_cluster/health";
    auto response = openSearchComm->IssueRequest(endpoint, HttpMethod::HTTP_GET, "", "", "", "");
    
    ASSERT_NE(response, nullptr);
    EXPECT_EQ(Aws::Http::HttpResponseCode::OK, response->GetResponseCode());
}

TEST(SettingSDKOptions, TurnLoggingOn) {
    Aws::SDKOptions options;
    options.loggingOptions.logLevel = Aws::Utils::Logging::LogLevel::Info;
    EXPECT_NO_THROW(Aws::InitAPI(options));
    EXPECT_NO_THROW(Aws::ShutdownAPI(options));
}

int main(int argc, char** argv) {
    testing::internal::CaptureStdout();
    ::testing::InitGoogleTest(&argc, argv);
    int failures = RUN_ALL_TESTS();
    std::string output = testing::internal::GetCapturedStdout();
    std::cout << output << std::endl;
    std::cout << (failures ? "Not all tests passed." : "All tests passed") << std::endl;
    WriteFileIfSpecified(argv, argv + argc, "-fout", output);
    return failures;
}
